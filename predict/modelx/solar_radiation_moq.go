// Code generated by moq; DO NOT EDIT.
// github.com/matryer/moq

package modelx

import (
	"context"
	"sync"
	"time"
)

// Ensure, that SolarRadiationMock does implement SolarRadiationInterface.
// If this is not the case, regenerate this file with moq.
var _ SolarRadiationInterface = &SolarRadiationMock{}

// SolarRadiationMock is a mock implementation of SolarRadiationInterface.
//
// 	func TestSomethingThatUsesSolarRadiationInterface(t *testing.T) {
//
// 		// make and configure a mocked SolarRadiationInterface
// 		mockedSolarRadiationInterface := &SolarRadiationMock{
// 			RadiationHistoryFunc: func(ctx context.Context, timeFrom time.Time, timeTo time.Time, coord *Coord) (*SolarRadiation, error) {
// 				panic("mock out the RadiationHistory method")
// 			},
// 			RadiationPredictionFunc: func(ctx context.Context, timeFrom time.Time, timeTo time.Time, coord *Coord) (*SolarRadiation, error) {
// 				panic("mock out the RadiationPrediction method")
// 			},
// 		}
//
// 		// use mockedSolarRadiationInterface in code that requires SolarRadiationInterface
// 		// and then make assertions.
//
// 	}
type SolarRadiationMock struct {
	// RadiationHistoryFunc mocks the RadiationHistory method.
	RadiationHistoryFunc func(ctx context.Context, timeFrom time.Time, timeTo time.Time, coord *Coord) (*SolarRadiation, error)

	// RadiationPredictionFunc mocks the RadiationPrediction method.
	RadiationPredictionFunc func(ctx context.Context, timeFrom time.Time, timeTo time.Time, coord *Coord) (*SolarRadiation, error)

	// calls tracks calls to the methods.
	calls struct {
		// RadiationHistory holds details about calls to the RadiationHistory method.
		RadiationHistory []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TimeFrom is the timeFrom argument value.
			TimeFrom time.Time
			// TimeTo is the timeTo argument value.
			TimeTo time.Time
			// Coord is the coord argument value.
			Coord *Coord
		}
		// RadiationPrediction holds details about calls to the RadiationPrediction method.
		RadiationPrediction []struct {
			// Ctx is the ctx argument value.
			Ctx context.Context
			// TimeFrom is the timeFrom argument value.
			TimeFrom time.Time
			// TimeTo is the timeTo argument value.
			TimeTo time.Time
			// Coord is the coord argument value.
			Coord *Coord
		}
	}
	lockRadiationHistory    sync.RWMutex
	lockRadiationPrediction sync.RWMutex
}

// RadiationHistory calls RadiationHistoryFunc.
func (mock *SolarRadiationMock) RadiationHistory(ctx context.Context, timeFrom time.Time, timeTo time.Time, coord *Coord) (*SolarRadiation, error) {
	if mock.RadiationHistoryFunc == nil {
		panic("SolarRadiationMock.RadiationHistoryFunc: method is nil but SolarRadiationInterface.RadiationHistory was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		TimeFrom time.Time
		TimeTo   time.Time
		Coord    *Coord
	}{
		Ctx:      ctx,
		TimeFrom: timeFrom,
		TimeTo:   timeTo,
		Coord:    coord,
	}
	mock.lockRadiationHistory.Lock()
	mock.calls.RadiationHistory = append(mock.calls.RadiationHistory, callInfo)
	mock.lockRadiationHistory.Unlock()
	return mock.RadiationHistoryFunc(ctx, timeFrom, timeTo, coord)
}

// RadiationHistoryCalls gets all the calls that were made to RadiationHistory.
// Check the length with:
//     len(mockedSolarRadiationInterface.RadiationHistoryCalls())
func (mock *SolarRadiationMock) RadiationHistoryCalls() []struct {
	Ctx      context.Context
	TimeFrom time.Time
	TimeTo   time.Time
	Coord    *Coord
} {
	var calls []struct {
		Ctx      context.Context
		TimeFrom time.Time
		TimeTo   time.Time
		Coord    *Coord
	}
	mock.lockRadiationHistory.RLock()
	calls = mock.calls.RadiationHistory
	mock.lockRadiationHistory.RUnlock()
	return calls
}

// RadiationPrediction calls RadiationPredictionFunc.
func (mock *SolarRadiationMock) RadiationPrediction(ctx context.Context, timeFrom time.Time, timeTo time.Time, coord *Coord) (*SolarRadiation, error) {
	if mock.RadiationPredictionFunc == nil {
		panic("SolarRadiationMock.RadiationPredictionFunc: method is nil but SolarRadiationInterface.RadiationPrediction was just called")
	}
	callInfo := struct {
		Ctx      context.Context
		TimeFrom time.Time
		TimeTo   time.Time
		Coord    *Coord
	}{
		Ctx:      ctx,
		TimeFrom: timeFrom,
		TimeTo:   timeTo,
		Coord:    coord,
	}
	mock.lockRadiationPrediction.Lock()
	mock.calls.RadiationPrediction = append(mock.calls.RadiationPrediction, callInfo)
	mock.lockRadiationPrediction.Unlock()
	return mock.RadiationPredictionFunc(ctx, timeFrom, timeTo, coord)
}

// RadiationPredictionCalls gets all the calls that were made to RadiationPrediction.
// Check the length with:
//     len(mockedSolarRadiationInterface.RadiationPredictionCalls())
func (mock *SolarRadiationMock) RadiationPredictionCalls() []struct {
	Ctx      context.Context
	TimeFrom time.Time
	TimeTo   time.Time
	Coord    *Coord
} {
	var calls []struct {
		Ctx      context.Context
		TimeFrom time.Time
		TimeTo   time.Time
		Coord    *Coord
	}
	mock.lockRadiationPrediction.RLock()
	calls = mock.calls.RadiationPrediction
	mock.lockRadiationPrediction.RUnlock()
	return calls
}
